#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "typer",
#     "rich",
# ]
# ///

import os
import pwd
import shutil
import subprocess
import sys
import uuid
from datetime import datetime
from pathlib import Path
from typing import List, NamedTuple, Optional, Tuple

import typer
from rich.console import Console
from rich.table import Table

console = Console()


def _validate_callback(ctx: typer.Context) -> None:
    """Typer callback to validate installation before any command."""
    # Skip validation for --help
    if ctx.resilient_parsing:
        return
    validate_travail_installation()


app = typer.Typer(
    help="CLI for managing the development container environment.",
    no_args_is_help=True,
    callback=_validate_callback,
)

IMAGE_NAME = "travail"


def get_travail_root() -> Path:
    """Get the travail repository root (parent of bin/)."""
    return Path(__file__).resolve().parent.parent


def validate_travail_installation() -> None:
    """Ensure travail is running from a valid installation.
    
    Checks for .travail marker file to prevent accidental operations
    if someone copies the binary to an unintended location.
    """
    root = get_travail_root()
    marker = root / ".travail"
    
    if not marker.is_file():
        console.print("[bold red]Error:[/bold red] Invalid travail installation.")
        console.print(f"  Missing marker file: {marker}")
        console.print()
        console.print("  The travail binary must be run from a proper clone.")
        console.print("  Do not copy bin/travail to another location.")
        raise typer.Exit(code=1)


def get_current_user_info() -> Tuple[int, int, str]:
    """Get the current user's UID, GID, and username."""
    uid = os.getuid()
    gid = os.getgid()
    try:
        username = os.environ.get("USER") or pwd.getpwuid(uid).pw_name
    except KeyError:
        username = "user" 
    return uid, gid, username

def run_command(cmd: List[str], check: bool = True, shell: bool = False) -> None:
    """Run a shell command."""
    try:
        subprocess.run(cmd, check=check, shell=shell)
    except subprocess.CalledProcessError as e:
        console.print(f"[bold red]Error running command:[/bold red] {e}")
        raise typer.Exit(code=1)

def get_docker_cmd(
    target_dir: Path,
    uid: int,
    gid: int,
    username: str,
    extra_mounts: Optional[List[str]] = None,
) -> List[str]:
    """Build the docker run command with all necessary mounts."""
    
    if extra_mounts is None:
        extra_mounts = []

    travail_root = get_travail_root()
    cache_dir = travail_root / ".cache"
    user_home_container = Path(f"/home/{username}")
    container_name = f"travail-{target_dir.name}-{str(uuid.uuid1())[:8]}"
    
    # Ensure cache dirs exist
    (cache_dir / "mise").mkdir(parents=True, exist_ok=True)
    
    cmd = [
        "docker", "run",
        "--rm", "-it",
        "--name", container_name,
        "-v", f"{target_dir}:/workspace",
        "-w", "/workspace",
        # Persist mise cache
        "-v", f"{cache_dir}/mise:{user_home_container}/.local/share/mise",
    ]
    
    # Process extra mounts
    for mount in extra_mounts:
        if ":" in mount:
            host_path_str, container_path = mount.split(":", 1)
            host_path = Path(host_path_str).resolve()
        else:
            host_path = Path(mount).resolve()
            container_path = f"/mounts/{host_path.name}"
            
        if host_path.exists():
            cmd.extend(["-v", f"{host_path}:{container_path}"])
        else:
            console.print(f"[yellow]Warning:[/yellow] Mount source '{host_path}' does not exist, skipping.")
    
    # Optional mounts from home directory
    home = Path.home()
    optional_mounts = [
        (home / ".gitconfig", user_home_container / ".gitconfig"),
        (home / ".local/share/opencode/auth.json", user_home_container / ".local/share/opencode/auth.json"),
        (home / ".config/opencode/opencode.json", user_home_container / ".config/opencode/opencode.json"),
    ]

    for src, dest in optional_mounts:
        if src.exists():
            cmd.extend(["-v", f"{src}:{dest}"])
    
    cmd.append(IMAGE_NAME)
    cmd.append("/bin/zsh") # Default command
    
    return cmd


def get_projects_dir() -> Path:
    """Get the projects directory relative to the travail root."""
    projects_dir = get_travail_root() / "projects"
    projects_dir.mkdir(exist_ok=True)
    return projects_dir


def derive_project_name(repo_url: str) -> str:
    """Extract project name from git URL.
    
    Examples:
    - git@github.com:acme/webapp.git -> webapp
    - https://github.com/acme/webapp.git -> webapp
    - https://github.com/acme/webapp -> webapp
    """
    url = repo_url.rstrip("/").removesuffix(".git")
    return url.split("/")[-1].split(":")[-1]


class GitInfo(NamedTuple):
    branch: str
    uncommitted: int
    last_modified: datetime


def get_git_info(path: Path) -> Optional[GitInfo]:
    """Get git info for a repository."""
    try:
        branch = subprocess.run(
            ["git", "branch", "--show-current"],
            cwd=path, capture_output=True, text=True, check=True
        ).stdout.strip()
        
        status = subprocess.run(
            ["git", "status", "--porcelain"],
            cwd=path, capture_output=True, text=True, check=True
        ).stdout.strip()
        uncommitted = len(status.splitlines()) if status else 0
        
        timestamp = subprocess.run(
            ["git", "log", "-1", "--format=%ct"],
            cwd=path, capture_output=True, text=True, check=True
        ).stdout.strip()
        last_modified = datetime.fromtimestamp(int(timestamp)) if timestamp else datetime.now()
        
        return GitInfo(branch, uncommitted, last_modified)
    except subprocess.CalledProcessError:
        return None


def format_time_ago(dt: datetime) -> str:
    """Format datetime as human-readable 'X ago' string."""
    delta = datetime.now() - dt
    seconds = delta.total_seconds()
    
    if seconds < 60:
        return "just now"
    elif seconds < 3600:
        mins = int(seconds // 60)
        return f"{mins}m ago"
    elif seconds < 86400:
        hours = int(seconds // 3600)
        return f"{hours}h ago"
    else:
        days = int(seconds // 86400)
        return f"{days}d ago"





# Command groups
project_app = typer.Typer(help="Manage projects", no_args_is_help=True)
feature_app = typer.Typer(help="Manage features", no_args_is_help=True)
app.add_typer(project_app, name="project")
app.add_typer(feature_app, name="feature")


# =============================================================================
# Project commands
# =============================================================================

@project_app.command("add")
def project_add(repo_url: str = typer.Argument(..., help="Git repository URL")) -> None:
    """Clone a repository as a new project."""
    name = derive_project_name(repo_url)
    projects_dir = get_projects_dir()
    project_dir = projects_dir / name
    base_dir = project_dir / "base"
    
    if project_dir.exists():
        console.print(f"[bold red]Error:[/bold red] Project '{name}' already exists")
        raise typer.Exit(code=1)
    
    project_dir.mkdir(parents=True)
    console.print(f"[green]Cloning {repo_url} into {base_dir}...[/green]")
    
    try:
        subprocess.run(["git", "clone", repo_url, "base"], cwd=project_dir, check=True)
        console.print(f"[bold green]Project '{name}' created at {project_dir}[/bold green]")
    except subprocess.CalledProcessError:
        shutil.rmtree(project_dir, ignore_errors=True)
        raise typer.Exit(code=1)


@project_app.command("list")
def project_list() -> None:
    """List all projects."""
    projects_dir = get_projects_dir()
    
    table = Table(title="Projects")
    table.add_column("Name", style="cyan")
    table.add_column("Branch", style="green")
    table.add_column("Status", style="yellow")
    table.add_column("Last Modified", style="dim")
    
    for project_path in sorted(projects_dir.iterdir()):
        if not project_path.is_dir():
            continue
        base_path = project_path / "base"
        if not base_path.exists():
            continue
        
        info = get_git_info(base_path)
        if info:
            status = "✓ clean" if info.uncommitted == 0 else f"{info.uncommitted} uncommitted"
            table.add_row(
                project_path.name,
                info.branch,
                status,
                format_time_ago(info.last_modified)
            )
        else:
            table.add_row(project_path.name, "?", "?", "?")
    
    console.print(table)


@project_app.command("pull")
def project_pull() -> None:
    """Pull latest changes for all projects (git pull origin)."""
    projects_dir = get_projects_dir()
    
    for project_path in sorted(projects_dir.iterdir()):
        if not project_path.is_dir():
            continue
            
        base_path = project_path / "base"
        if not base_path.exists():
            continue
            
        console.print(f"[bold cyan]Project: {project_path.name}[/bold cyan]")
        try:
            # We capture output to keep it clean, but if it fails we show stderr
            result = subprocess.run(
                ["git", "pull", "origin"],
                cwd=base_path,
                capture_output=True,
                text=True,
                check=True
            )
            console.print("  [green]Success[/green]")
        except subprocess.CalledProcessError as e:
            console.print(f"  [red]Failed:[/red] {e.stderr.strip()}")
            console.print(f"  [dim]Command output: {e.stdout.strip()}[/dim]")


# =============================================================================
# Feature commands
# =============================================================================

@feature_app.command("add")
def feature_add(
    project: str = typer.Argument(..., help="Project name"),
    name: str = typer.Argument(..., help="Feature name")
) -> None:
    """Create a new feature from project base."""
    projects_dir = get_projects_dir()
    project_dir = projects_dir / project
    base_dir = project_dir / "base"
    feature_dir = project_dir / name
    
    if not base_dir.exists():
        console.print(f"[bold red]Error:[/bold red] Project '{project}' not found")
        raise typer.Exit(code=1)
    
    if feature_dir.exists():
        console.print(f"[bold red]Error:[/bold red] Feature '{name}' already exists")
        raise typer.Exit(code=1)
    
    # Pull latest in base
    console.print(f"[green]Pulling latest changes in base...[/green]")
    try:
        subprocess.run(["git", "pull", "origin"], cwd=base_dir, check=True)
    except subprocess.CalledProcessError:
        console.print(f"[bold yellow]Warning:[/bold yellow] Failed to pull, continuing anyway...")
    
    # Copy base to feature
    console.print(f"[green]Creating feature '{name}'...[/green]")
    shutil.copytree(base_dir, feature_dir)
    
    # Create feature branch
    branch_name = f"feat/{name}"
    try:
        subprocess.run(["git", "checkout", "-b", branch_name], cwd=feature_dir, check=True)
    except subprocess.CalledProcessError:
        console.print(f"[bold red]Error:[/bold red] Failed to create branch")
        shutil.rmtree(feature_dir, ignore_errors=True)
        raise typer.Exit(code=1)
    
    console.print(f"[bold green]Feature created at {feature_dir}[/bold green]")


@feature_app.command("list")
def feature_list(
    project: Optional[str] = typer.Argument(None, help="Project name (optional, lists all if omitted)")
) -> None:
    """List features, optionally filtered by project."""
    projects_dir = get_projects_dir()
    
    table = Table(title="Features")
    table.add_column("Project", style="cyan")
    table.add_column("Feature", style="magenta")
    table.add_column("Branch", style="green")
    table.add_column("Status", style="yellow")
    table.add_column("Last Modified", style="dim")
    
    projects_to_scan = []
    if project:
        project_path = projects_dir / project
        if not project_path.exists():
            console.print(f"[bold red]Error:[/bold red] Project '{project}' not found")
            raise typer.Exit(code=1)
        projects_to_scan = [project_path]
    else:
        projects_to_scan = sorted(projects_dir.iterdir())
    
    for project_path in projects_to_scan:
        if not project_path.is_dir():
            continue
        
        for feature_path in sorted(project_path.iterdir()):
            if not feature_path.is_dir() or feature_path.name == "base":
                continue
            
            info = get_git_info(feature_path)
            if info:
                status = "✓ clean" if info.uncommitted == 0 else f"{info.uncommitted} uncommitted"
                table.add_row(
                    project_path.name,
                    feature_path.name,
                    info.branch,
                    status,
                    format_time_ago(info.last_modified)
                )
    
    console.print(table)


def enter_container(target_dir: Path, mounts: Optional[List[str]] = None) -> None:
    """Enter the container for the target directory."""
    if not target_dir.exists():
        console.print(f"[bold red]Error:[/bold red] Directory not found: {target_dir}")
        raise typer.Exit(code=1)
    
    uid, gid, username = get_current_user_info()
    docker_cmd_list = get_docker_cmd(
        target_dir.resolve(), uid, gid, username, mounts
    )
    docker_cmd_str = " ".join(docker_cmd_list)

    console.print(f"[bold blue]Exec:[/bold blue] {docker_cmd_str}")
    sys.stdout.flush()
    try:
        os.execvp("docker", docker_cmd_list)
    except OSError as e:
        console.print(f"[bold red]Failed to execute docker:[/bold red] {e}")
        raise typer.Exit(code=1)


@app.command("shell")
def shell(
    path: Optional[Path] = typer.Argument(None, help="Target directory (defaults to current)"),
    mounts: Optional[List[str]] = typer.Option(None, "--mount", "-m", help="Additional mounts (format: /host/path or /host/path:/container/path)"),
) -> None:
    """Enter the development container for the specified directory."""
    target_dir = path.resolve() if path else Path.cwd()
    enter_container(target_dir, mounts)


@feature_app.command("remove")
def feature_remove(
    project: str = typer.Argument(..., help="Project name"),
    name: str = typer.Argument(..., help="Feature name")
) -> None:
    """Remove a feature."""
    projects_dir = get_projects_dir()
    feature_dir = projects_dir / project / name
    
    if not feature_dir.exists():
        console.print(f"[bold red]Error:[/bold red] Feature '{name}' not found in project '{project}'")
        raise typer.Exit(code=1)
    
    if feature_dir.name == "base":
        console.print(f"[bold red]Error:[/bold red] Cannot remove 'base'")
        raise typer.Exit(code=1)
    
    # Confirm
    confirm = typer.confirm(f"Remove feature '{name}' from project '{project}'? This cannot be undone.")
    if not confirm:
        console.print("[yellow]Cancelled[/yellow]")
        raise typer.Exit(code=0)
    
    shutil.rmtree(feature_dir)
    console.print(f"[bold green]Feature '{name}' removed[/bold green]")


# =============================================================================
# Global commands
# =============================================================================

@app.command()
def setup() -> None:
    """
    Build the Docker image.
    """
    uid, gid, username = get_current_user_info()
    travail_root = get_travail_root()
    
    console.print(f"[green]Building image '{IMAGE_NAME}' for user '{username}' ({uid}:{gid})...[/green]")
    
    cmd = [
        "docker", "build",
        "--no-cache",
        "--build-arg", f"UID={uid}",
        "--build-arg", f"GID={gid}",
        "--build-arg", f"USERNAME={username}",
        "-t", IMAGE_NAME,
        "-f", str(travail_root / "Dockerfile"),
        str(travail_root)
    ]
        
    run_command(cmd)
    console.print(f"[bold green]Successfully built {IMAGE_NAME}![/bold green]")

if __name__ == "__main__":
    app()
