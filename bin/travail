#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "typer",
#     "rich",
# ]
# ///

import os
import pwd
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import List, NamedTuple, Optional, Tuple

import typer
from rich.console import Console
from rich.table import Table

console = Console()


def _validate_callback(ctx: typer.Context) -> None:
    """Typer callback to validate installation before any command."""
    # Skip validation for --help
    if ctx.resilient_parsing:
        return
    validate_travail_installation()


app = typer.Typer(
    help="CLI for managing the development container environment.",
    no_args_is_help=True,
    callback=_validate_callback,
)

IMAGE_NAME = "travail"


def get_travail_root() -> Path:
    """Get the travail repository root (parent of bin/)."""
    return Path(__file__).resolve().parent.parent


def validate_travail_installation() -> None:
    """Ensure travail is running from a valid installation.
    
    Checks for .travail marker file to prevent accidental operations
    if someone copies the binary to an unintended location.
    """
    root = get_travail_root()
    marker = root / ".travail"
    
    if not marker.is_file():
        console.print("[bold red]Error:[/bold red] Invalid travail installation.")
        console.print(f"  Missing marker file: {marker}")
        console.print()
        console.print("  The travail binary must be run from a proper clone.")
        console.print("  Do not copy bin/travail to another location.")
        raise typer.Exit(code=1)


def get_current_user_info() -> Tuple[int, int, str]:
    """Get the current user's UID, GID, and username."""
    uid = os.getuid()
    gid = os.getgid()
    try:
        username = os.environ.get("USER") or pwd.getpwuid(uid).pw_name
    except KeyError:
        username = "user" 
    return uid, gid, username

def run_command(cmd: List[str], check: bool = True, shell: bool = False) -> None:
    """Run a shell command."""
    try:
        subprocess.run(cmd, check=check, shell=shell)
    except subprocess.CalledProcessError as e:
        console.print(f"[bold red]Error running command:[/bold red] {e}")
        raise typer.Exit(code=1)

def get_docker_cmd(
    target_dir: Path,
    uid: int,
    gid: int,
    username: str,
    project: str,
    feature: str,
    is_base: bool = False,
) -> List[str]:
    """Build the docker run command with all necessary mounts."""
    
    travail_root = get_travail_root()
    cache_dir = travail_root / ".cache"
    user_home_container = Path(f"/home/{username}")
    container_name = f"travail/{project}/{feature}"
    
    # Ensure cache dirs exist
    (cache_dir / "mise").mkdir(parents=True, exist_ok=True)
    
    cmd = [
        "docker", "run",
        "--rm", "-it",
        "--name", container_name,
        "-v", f"{target_dir}:/workspace",
        "-w", "/workspace",
        # Persist mise cache
        "-v", f"{cache_dir}/mise:{user_home_container}/.local/share/mise",
    ]
    
    # Pass flag to entrypoint if entering base directory
    if is_base:
        cmd.extend(["-e", "TRAVAIL_IS_BASE=1"])

    # Optional mounts from home directory
    home = Path.home()
    optional_mounts = [
        (home / ".gitconfig", user_home_container / ".gitconfig"),
        (home / ".local/share/opencode/auth.json", user_home_container / ".local/share/opencode/auth.json"),
        (home / ".config/opencode/opencode.json", user_home_container / ".config/opencode/opencode.json"),
    ]

    for src, dest in optional_mounts:
        if src.exists():
            cmd.extend(["-v", f"{src}:{dest}"])
    

            
    cmd.append(IMAGE_NAME)
    cmd.append("/bin/zsh") # Default command
    
    return cmd


def get_projects_dir() -> Path:
    """Get the projects directory relative to the travail root."""
    projects_dir = get_travail_root() / "projects"
    projects_dir.mkdir(exist_ok=True)
    return projects_dir


def derive_project_name(repo_url: str) -> str:
    """Extract project name from git URL.
    
    Examples:
    - git@github.com:acme/webapp.git -> webapp
    - https://github.com/acme/webapp.git -> webapp
    - https://github.com/acme/webapp -> webapp
    """
    url = repo_url.rstrip("/").removesuffix(".git")
    return url.split("/")[-1].split(":")[-1]


class GitInfo(NamedTuple):
    branch: str
    uncommitted: int
    last_modified: datetime


def get_git_info(path: Path) -> Optional[GitInfo]:
    """Get git info for a repository."""
    try:
        branch = subprocess.run(
            ["git", "branch", "--show-current"],
            cwd=path, capture_output=True, text=True, check=True
        ).stdout.strip()
        
        status = subprocess.run(
            ["git", "status", "--porcelain"],
            cwd=path, capture_output=True, text=True, check=True
        ).stdout.strip()
        uncommitted = len(status.splitlines()) if status else 0
        
        timestamp = subprocess.run(
            ["git", "log", "-1", "--format=%ct"],
            cwd=path, capture_output=True, text=True, check=True
        ).stdout.strip()
        last_modified = datetime.fromtimestamp(int(timestamp)) if timestamp else datetime.now()
        
        return GitInfo(branch, uncommitted, last_modified)
    except subprocess.CalledProcessError:
        return None


def format_time_ago(dt: datetime) -> str:
    """Format datetime as human-readable 'X ago' string."""
    delta = datetime.now() - dt
    seconds = delta.total_seconds()
    
    if seconds < 60:
        return "just now"
    elif seconds < 3600:
        mins = int(seconds // 60)
        return f"{mins}m ago"
    elif seconds < 86400:
        hours = int(seconds // 3600)
        return f"{hours}h ago"
    else:
        days = int(seconds // 86400)
        return f"{days}d ago"


def detect_context(cwd: Path) -> Tuple[Optional[str], Optional[str], bool]:
    """Detect if cwd is inside a project/feature.
    
    Returns: (project_name, feature_name_or_none, is_base)
    """
    projects_dir = get_projects_dir()
    try:
        rel = cwd.relative_to(projects_dir)
        parts = rel.parts
        if len(parts) >= 2:
            project = parts[0]
            feature_or_base = parts[1]
            is_base = feature_or_base == "base"
            return (project, None if is_base else feature_or_base, is_base)
        elif len(parts) == 1:
            return (parts[0], None, False)
    except ValueError:
        pass
    return (None, None, False)


def is_base_dir(path: Path) -> bool:
    """Check if path is a base directory."""
    return path.name == "base"


# Command groups
project_app = typer.Typer(help="Manage projects", no_args_is_help=True)
feature_app = typer.Typer(help="Manage features", no_args_is_help=True)
app.add_typer(project_app, name="project")
app.add_typer(feature_app, name="feature")


# =============================================================================
# Project commands
# =============================================================================

@project_app.command("add")
def project_add(repo_url: str = typer.Argument(..., help="Git repository URL")) -> None:
    """Clone a repository as a new project."""
    name = derive_project_name(repo_url)
    projects_dir = get_projects_dir()
    project_dir = projects_dir / name
    base_dir = project_dir / "base"
    
    if project_dir.exists():
        console.print(f"[bold red]Error:[/bold red] Project '{name}' already exists")
        raise typer.Exit(code=1)
    
    project_dir.mkdir(parents=True)
    console.print(f"[green]Cloning {repo_url} into {base_dir}...[/green]")
    
    try:
        subprocess.run(["git", "clone", repo_url, "base"], cwd=project_dir, check=True)
        console.print(f"[bold green]Project '{name}' created at {project_dir}[/bold green]")
    except subprocess.CalledProcessError:
        shutil.rmtree(project_dir, ignore_errors=True)
        raise typer.Exit(code=1)


@project_app.command("list")
def project_list() -> None:
    """List all projects."""
    projects_dir = get_projects_dir()
    
    table = Table(title="Projects")
    table.add_column("Name", style="cyan")
    table.add_column("Branch", style="green")
    table.add_column("Status", style="yellow")
    table.add_column("Last Modified", style="dim")
    
    for project_path in sorted(projects_dir.iterdir()):
        if not project_path.is_dir():
            continue
        base_path = project_path / "base"
        if not base_path.exists():
            continue
        
        info = get_git_info(base_path)
        if info:
            status = "✓ clean" if info.uncommitted == 0 else f"{info.uncommitted} uncommitted"
            table.add_row(
                project_path.name,
                info.branch,
                status,
                format_time_ago(info.last_modified)
            )
        else:
            table.add_row(project_path.name, "?", "?", "?")
    
    console.print(table)


# =============================================================================
# Feature commands
# =============================================================================

@feature_app.command("new")
def feature_new(
    project: str = typer.Argument(..., help="Project name"),
    name: str = typer.Argument(..., help="Feature name")
) -> None:
    """Create a new feature from project base."""
    projects_dir = get_projects_dir()
    project_dir = projects_dir / project
    base_dir = project_dir / "base"
    feature_dir = project_dir / name
    
    if not base_dir.exists():
        console.print(f"[bold red]Error:[/bold red] Project '{project}' not found")
        raise typer.Exit(code=1)
    
    if feature_dir.exists():
        console.print(f"[bold red]Error:[/bold red] Feature '{name}' already exists")
        raise typer.Exit(code=1)
    
    # Pull latest in base
    console.print(f"[green]Pulling latest changes in base...[/green]")
    try:
        subprocess.run(["git", "pull", "origin"], cwd=base_dir, check=True)
    except subprocess.CalledProcessError:
        console.print(f"[bold yellow]Warning:[/bold yellow] Failed to pull, continuing anyway...")
    
    # Copy base to feature
    console.print(f"[green]Creating feature '{name}'...[/green]")
    shutil.copytree(base_dir, feature_dir)
    
    # Create feature branch
    branch_name = f"feat/{name}"
    try:
        subprocess.run(["git", "checkout", "-b", branch_name], cwd=feature_dir, check=True)
    except subprocess.CalledProcessError:
        console.print(f"[bold red]Error:[/bold red] Failed to create branch")
        shutil.rmtree(feature_dir, ignore_errors=True)
        raise typer.Exit(code=1)
    
    console.print(f"[bold green]Feature created at {feature_dir}[/bold green]")


@feature_app.command("list")
def feature_list(
    project: Optional[str] = typer.Argument(None, help="Project name (optional, lists all if omitted)")
) -> None:
    """List features, optionally filtered by project."""
    projects_dir = get_projects_dir()
    
    table = Table(title="Features")
    table.add_column("Project", style="cyan")
    table.add_column("Feature", style="magenta")
    table.add_column("Branch", style="green")
    table.add_column("Status", style="yellow")
    table.add_column("Last Modified", style="dim")
    
    projects_to_scan = []
    if project:
        project_path = projects_dir / project
        if not project_path.exists():
            console.print(f"[bold red]Error:[/bold red] Project '{project}' not found")
            raise typer.Exit(code=1)
        projects_to_scan = [project_path]
    else:
        projects_to_scan = sorted(projects_dir.iterdir())
    
    for project_path in projects_to_scan:
        if not project_path.is_dir():
            continue
        
        for feature_path in sorted(project_path.iterdir()):
            if not feature_path.is_dir() or feature_path.name == "base":
                continue
            
            info = get_git_info(feature_path)
            if info:
                status = "✓ clean" if info.uncommitted == 0 else f"{info.uncommitted} uncommitted"
                table.add_row(
                    project_path.name,
                    feature_path.name,
                    info.branch,
                    status,
                    format_time_ago(info.last_modified)
                )
    
    console.print(table)


@feature_app.command("enter")
def feature_enter(
    arg1: Optional[str] = typer.Argument(None, help="Project or feature name (context-dependent)"),
    arg2: Optional[str] = typer.Argument(None, help="Feature name (when first arg is project)")
) -> None:
    """Enter the development container for a feature.
    
    Context-aware argument handling:
    - Inside a project dir: single arg is treated as feature name
    - Outside project dirs: both project and feature args required
    """
    projects_dir = get_projects_dir()
    
    # Detect current context
    detected_project, detected_feature, is_base = detect_context(Path.cwd())
    
    if arg1 and arg2:
        project, feature = arg1, arg2
    elif arg1 and not arg2:
        if detected_project:
            project, feature = detected_project, arg1
        else:
            console.print(f"[bold red]Error:[/bold red] Outside project directory. Please specify both project and feature.")
            raise typer.Exit(code=1)
    elif detected_project and detected_feature:
        project, feature = detected_project, detected_feature
    elif detected_project and is_base:
        project, feature = detected_project, "base"
    elif detected_project:
        console.print(f"[bold red]Error:[/bold red] Please specify a feature name")
        raise typer.Exit(code=1)
    else:
        console.print(f"[bold red]Error:[/bold red] Not inside a project directory. Please specify project and feature.")
        raise typer.Exit(code=1)
    
    target_dir = projects_dir / project / feature
    
    # Validate target exists
    if not target_dir.exists():
        console.print(f"[bold red]Error:[/bold red] Directory not found: {target_dir}")
        raise typer.Exit(code=1)
    
    uid, gid, username = get_current_user_info()
    is_base = is_base_dir(target_dir)
    docker_cmd_list = get_docker_cmd(
        target_dir.resolve(), uid, gid, username,
        project=project, feature=feature, is_base=is_base,
    )
    docker_cmd_str = " ".join(docker_cmd_list)

    console.print(f"[bold blue]Exec:[/bold blue] {docker_cmd_str}")
    sys.stdout.flush()
    try:
        os.execvp("docker", docker_cmd_list)
    except OSError as e:
        console.print(f"[bold red]Failed to execute docker:[/bold red] {e}")
        raise typer.Exit(code=1)


@feature_app.command("remove")
def feature_remove(
    project: str = typer.Argument(..., help="Project name"),
    name: str = typer.Argument(..., help="Feature name")
) -> None:
    """Remove a feature."""
    projects_dir = get_projects_dir()
    feature_dir = projects_dir / project / name
    
    if not feature_dir.exists():
        console.print(f"[bold red]Error:[/bold red] Feature '{name}' not found in project '{project}'")
        raise typer.Exit(code=1)
    
    if feature_dir.name == "base":
        console.print(f"[bold red]Error:[/bold red] Cannot remove 'base'")
        raise typer.Exit(code=1)
    
    # Confirm
    confirm = typer.confirm(f"Remove feature '{name}' from project '{project}'? This cannot be undone.")
    if not confirm:
        console.print("[yellow]Cancelled[/yellow]")
        raise typer.Exit(code=0)
    
    shutil.rmtree(feature_dir)
    console.print(f"[bold green]Feature '{name}' removed[/bold green]")


# =============================================================================
# Global commands
# =============================================================================

@app.command()
def setup(
    no_cache: bool = typer.Option(False, "--no-cache", help="Do not use cache when building."),
) -> None:
    """
    Build the Docker image.
    """
    uid, gid, username = get_current_user_info()
    travail_root = get_travail_root()
    
    console.print(f"[green]Building image '{IMAGE_NAME}' for user '{username}' ({uid}:{gid})...[/green]")
    
    cmd = [
        "docker", "build",
        "--build-arg", f"UID={uid}",
        "--build-arg", f"GID={gid}",
        "--build-arg", f"USERNAME={username}",
        "-t", IMAGE_NAME,
        "-f", str(travail_root / "Dockerfile"),
        str(travail_root)
    ]
    
    if no_cache:
        cmd.append("--no-cache")
        
    run_command(cmd)
    console.print(f"[bold green]Successfully built {IMAGE_NAME}![/bold green]")

if __name__ == "__main__":
    app()
